<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="author" content="Anton Sukhachev">
    <title>SQLite Index Visualization: Search</title>
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>

    <meta name="description" content="In the previous post, I explained how to extract data from SQLite Indexes and make it visual.This ti..."/>
    <meta name="keywords" content="anton sukhachev, mrsuh"/>

    <meta property="og:type" content="website">
    <meta property="og:site_name" content="mrsuh.com">
    <meta property="og:url" content="https://mrsuh.com/articles/2024/sqlite-index-visualization-search/">
    <meta property="og:title" content="SQLite Index Visualization: Search">
    <meta property="og:description" content="In the previous post, I explained how to extract data from SQLite Indexes and make it visual.This ti...">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:alt" content="Anton Sukhachev">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="mrsuh.com">
    <meta name="twitter:url" content="https://mrsuh.com/articles/2024/sqlite-index-visualization-search/">
    <meta name="twitter:title" content="SQLite Index Visualization: Search">
    <meta name="twitter:creator" content="@mrsuh6">
    <meta name="twitter:description" content="In the previous post, I explained how to extract data from SQLite Indexes and make it visual.This ti...">
    <meta name="twitter:image:alt" content="Anton Sukhachev">
    
    <link href="/bootstrap.min.css" rel="stylesheet">
    <link href="/style.css?v=1" rel="stylesheet">
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-GMXWT1YP3F"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-GMXWT1YP3F');
</script>

<body class="container fs-5" style="max-width: 1000px">

<div class="header" style="padding-top: 20px; padding-bottom: 10px">
    <div class="row">
        <div class="col">
            <a href="/">Anton Sukhachev</a>
        </div>
        <div class="col text-end">
            <a href="/articles/">Articles</a>
        </div>
    </div>
    <hr/>
</div>

<div class="content">
    <h1>SQLite Index Visualization: Search</h1>
<p>In the previous <a href="/articles/2024/sqlite-index-visualization-structure/">post</a>, I explained how to extract data from SQLite Indexes and make it visual.<br />
This time, I'll try to show what a search inside an Index looks like.</p>
<a href="#h2-how-does-sqlite-search-within-an-index?" id="h2-how-does-sqlite-search-within-an-index?" class="text-decoration-none text-reset"><h2>How does SQLite search within an Index?</h2></a>
<p><a href="./images/b-tree-sqlite-search.svg"><img src="./images/b-tree-sqlite-search.svg" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>Inside each Page, SQLite performs a binary search among Cell values. After finding the closest match, it picks the left child of that Cell.<br />
If all Cell values on the Page are smaller than the target, it selects the Page’s right child.</p>
<p>If we compile SQLite with <a href="https://www.sqlite.org/debugging.html" target="_blank">debugging</a> enabled and turn it on for queries, we can get detailed information about how the query work internally.<br />
First, we should know that SQLite has a virtual machine. Even using a simple EXPLAIN command, we can view the virtual machine’s OPCODEs, its registers (p1, p2...), and comments.<br />
You can learn more about its internals <a href="https://www.sqlite.org/opcode.html" target="_blank">here</a>.</p>
<pre><code class="language-sql rounded">EXPLAIN SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 = 1;
addr  opcode         p1    p2    p3    p4             p5  comment      
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     11    0                    0   Start at 11
1     OpenRead       1     2694  0     k(2,,)         2   root=2694 iDb=0; idx
2     Explain        2     0     0     SEARCH table_test USING COVERING INDEX idx (column1=?) 0   
3     Integer        1     1     0                    0   r[1]=1
4     SeekGE         1     10    1     1              0   key=r[1]
5       IdxGT          1     10    1     1              0   key=r[1]
6       IdxRowid       1     2     0                    0   r[2]=rowid; table_test.rowid
7       Column         1     0     3                    0   r[3]= cursor 1 column 0
8       ResultRow      2     2     0                    0   output=r[2..3]
9     Next           1     5     1                    0   
10    Halt           0     0     0                    0   
11    Transaction    0     0     3     0              1   usesStmtJournal=0
12    TableLock      0     2     0     table_test     0   iDb=0 root=2 write=0
13    Goto           0     1     0                    0</code></pre>
<p>The EXPLAIN output shows the root Page number of the Index, the OPCODEs used to search within the Index, and the related values for each step:</p>
<pre><code class="language-bash rounded">1     OpenRead       1     2694  0     k(2,,)         2   root=2694 iDb=0; idx
...
3     Integer        1     1     0                    0   r[1]=1
4     SeekGE         1     10    1     1              0   key=r[1]</code></pre>
<p>Once the query finishes, we can look at the search counter to see how many times the data was searched in the Index:</p>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 = 1;
.testctrl seek_count
1</code></pre>
<p>We can't get more detailed information about pages and cells from the EXPLAIN output.<br />
I dug into the code and <a href="https://github.com/mrsuh/sqlite-index/blob/main/sqlite.patch" target="_blank">added</a> functions to track all the Pages and Cells read during the search.<br />
Example of code:</p>
<pre><code class="language-c rounded">if (sqlite3DebugIsBtreeIndexSeekEnabled()) {
  char **payload = sqlite3DebugGetCellPayloadAndRowId(pCur, pPage, idx);
  printf(
      "sqlite3DebugBtreeIndexMoveto: pageNumber=%d, cellNumber=%d, payload=%s, rowId=%s\n",
      pPage-&gt;pgno,
      idx,
      payload[0],
      payload[1]
  );
  sqlite3DebugFreeCellPayloadAndRowId(payload);
}</code></pre>
<p>The output looks like this:</p>
<pre><code class="language-bash rounded">sqlite3DebugMoveToRoot:
sqlite3DebugBtreeIndexMoveto: pageNumber=2694, cellNumber=5, payload=532656, rowId=532656
sqlite3DebugBtreeIndexCompare: index=1, type=int, value=1
sqlite3DebugBtreeIndexMoveto: pageNumber=2694, cellNumber=2, payload=270768, rowId=270768
sqlite3DebugBtreeIndexCompare: index=1, type=int, value=1
...
sqlite3DebugBtreeIndexMoveto: pageNumber=2695, cellNumber=0, payload=1, rowId=1
sqlite3DebugBtreeIndexCompare: index=1, type=int, value=1
sqlite3DebugResultRow:
1|1</code></pre>
<p>This provides a detailed trace of the Pages and Cells used in the search, letting us count the basic operations and compare them to the expected complexity of the algorithm.<br />
Then, I updated the Index visualization code, and here’s the result:</p>
<p><a href="./images/search-equal.webp"><img src="./images/search-equal.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>In the top-left corner, we can see general information about the Index and specific search details:</p>
<ul>
<li>total Pages and Cells in the Index;</li>
<li>number of Pages loaded during the search;</li>
<li>number of Cells checked during the search;</li>
<li>count of Index searches for the data;</li>
<li>count of Cell comparisons;</li>
<li>number of filtered Cells.</li>
</ul>
<p>The searched Cell and its linked Cells are highlighted in bright colors.</p>
<p>Information about the number of filtered Cells:</p>
<pre><code class="language-sql rounded">SELECT * FROM table WHERE column = 10;</code></pre>
<p>In this query, SQLite first finds the cell with the value 10, then checks the following cells since they could also have the value 10.<br />
So, instead of performing more searching, it reads the next cells to filter them. This means that for simple queries, there’s usually at least one filtering step.</p>
<p>To create this image, we’ll need dumps of both the Index and the search.<br />
We can get these with the following commands:</p>
<pre><code class="language-bash rounded">docker run -it --rm -v "$PWD":/app/data --platform linux/x86_64 mrsuh/sqlite-index bash
sh bin/dump-index.sh database.sqlite "SELECT column1 FROM table_test INDEXED BY idx WHERE column1 = 1;" dump-index.txt
sh bin/dump-search.sh database.sqlite "SELECT column1 FROM table_test INDEXED BY idx WHERE column1 = 1;" dump-search.txt
php bin/console app:render-search --dumpIndexPath=dump-index.txt --dumpSearchPath=dump-search.txt --outputImagePath=image.webp</code></pre>
<p>The search dump file contain a lot of useful details about the query:</p>
<pre><code class="language-bash rounded">### QUERY
SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 = 1;

### EXPLAIN QUERY PLAN
`--SEARCH table_test USING COVERING INDEX idx (column1=?)

### EXPLAIN QUERY
addr  opcode         p1    p2    p3    p4             p5  comment      
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     11    0                    0   Start at 11
1     OpenRead       1     2694  0     k(2,,)         2   root=2694 iDb=0; idx

...

### RESULT
rowid  column1
-----  -------
1      1      </code></pre>
<p>Let’s experiment!<br />
Before each Index image, I'll show the table's data structure, the way the Index was made, and how the table was filled with data.</p>
<a href="#h2-query-with-a-single-column-and-equality-condition" id="h2-query-with-a-single-column-and-equality-condition" class="text-decoration-none text-reset"><h2>Query with a single column and equality condition</h2></a>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 = 1;
rowid  column1
-----  -------
1      1</code></pre>
<p><a href="./images/search-equal.webp"><img src="./images/search-equal.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>We read 3 Pages, compared 19 Cells, and filtered out one Cell. In this example, the actual number of comparisons is 19, which is lower than the theoretical worst-case for binary search: </p>
<pre><code class="language-bash rounded">O(log2(n)) -&gt; O(log2(1.000.000)) -&gt; 19.93</code></pre>
<a href="#h2-query-with-multiple-values-in-in()" id="h2-query-with-multiple-values-in-in()" class="text-decoration-none text-reset"><h2>Query with multiple values in IN()</h2></a>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 IN (1,1000000);
rowid    column1
-------  -------
1        1      
1000000  1000000</code></pre>
<p><a href="./images/search-range-1000000.webp"><img src="./images/search-range-1000000.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>For each value in the <code>IN()</code> list, SQLite performs a separate search in the Index. Sometimes, optimizations can reduce the number of searches, but generally, the database will go through the Index from the root to the target value for each item in the <code>IN()</code> list.</p>
<a href="#h2-comparing-searches-in-asc/desc-indexes" id="h2-comparing-searches-in-asc/desc-indexes" class="text-decoration-none text-reset"><h2>Comparing searches in ASC/DESC Indexes</h2></a>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
CREATE INDEX idx_asc ON table_test (column1 ASC);
CREATE INDEX idx_desc ON table_test (column1 DESC);</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx_asc WHERE column1 IN (1,500000,1000000);
rowid    column1
-------  -------
1        1      
500000   500000 
1000000  1000000</code></pre>
<p><a href="./images/search-order-asc.webp"><img src="./images/search-order-asc.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>Here, three values are being searched, and each one requires an Index lookup. There are fewer filters than lookups because no filtering is needed after the last value.</p>
<a href="#h2-descending-order-search" id="h2-descending-order-search" class="text-decoration-none text-reset"><h2>Descending order search</h2></a>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx_desc WHERE column1 IN (1,500000,1000000);
rowid    column1
-------  -------
1000000  1000000
500000   500000 
1        1</code></pre>
<p><a href="./images/search-order-desc.webp"><img src="./images/search-order-desc.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>As shown, searching in a DESC Index works the same as searching in an ASC Index in general cases.</p>
<a href="#h2-range-searches" id="h2-range-searches" class="text-decoration-none text-reset"><h2>Range searches</h2></a>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 &gt;= 500000 LIMIT 5;
rowid   column1
------  -------
500000  500000 
500001  500001 
500002  500002 
500003  500003 
500004  500004</code></pre>
<p><a href="./images/search-greater-than.webp"><img src="./images/search-greater-than.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>In this query, the target value was found after 20 comparisons, with 0 filtering. This is because the search was done on an ascending (ASC) Index with a <code>&gt;=</code> comparison.<br />
SQLite just read the next several values, and no further comparisons were needed since the data in the Index was already sorted in the required order.</p>
<a href="#h2-expression-based-searches" id="h2-expression-based-searches" class="text-decoration-none text-reset"><h2>Expression-based searches</h2></a>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 TEXT NOT NULL);
INSERT INTO table_test (column1) VALUES ('{"timestamp":1}'),('{"timestamp":2}'),('{"timestamp":3}'),...,('{"timestamp":999998}'),('{"timestamp":999999}'),('{"timestamp":1000000}');
CREATE INDEX idx ON table_test (strftime('%Y-%m-%d %H:%M:%S', json_extract(column1, '$.timestamp'), 'unixepoch') ASC);</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, strftime('%Y-%m-%d %H:%M:%S',json_extract(column1, '$.timestamp'), 'unixepoch') AS date FROM table_test INDEXED BY idx WHERE strftime('%Y-%m-%d %H:%M:%S',json_extract(column1, '$.timestamp'), 'unixepoch') = '1970-01-01 00:00:01';
rowid  date               
-----  -------------------
1      1970-01-01 00:00:01</code></pre>
<p><a href="./images/search-expression.webp"><img src="./images/search-expression.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>A search for an exact value created by an expression is just as fast as a simple number search in terms of the number of Cells compared.<br />
No matter how complex the expression, the search using the Index will still be quick. The key is that the expression in the Index must exactly match the expression in the query.</p>
<p>For example, if we have an Index like this:</p>
<pre><code class="language-sql rounded">CREATE INDEX idx ON table_test (column1 + column2);</code></pre>
<p>SQLite will not use the Index for this query:</p>
<pre><code class="language-sql rounded">SELECT * FROM table_test WHERE (column2 + column1) = 1</code></pre>
<p>The expressions are the same in meaning but different in how they are written. You must use the exact expression as it is in the Index:</p>
<pre><code class="language-sql rounded">SELECT * FROM table_test WHERE (column1 + column2) = 1</code></pre>
<a href="#h2-searching-within-a-unique-index-where-nearly-all-values-are-filled-with-null" id="h2-searching-within-a-unique-index-where-nearly-all-values-are-filled-with-null" class="text-decoration-none text-reset"><h2>Searching within a unique Index where nearly all values are filled with NULL</h2></a>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT)
INSERT INTO table_test (column1) VALUES (1),(NULL),(NULL),...,(NULL),(NULL),(1000000);
CREATE UNIQUE INDEX idx ON table_test (column1 ASC);</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 = 1;
rowid  column1
-----  -------
1      1</code></pre>
<p><a href="./images/search-unique.webp"><img src="./images/search-unique.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>This query does not differ from an Index without NULL values in terms of the number of Cells read.</p>
<a href="#h2-searching-in-an-index-without-null-values" id="h2-searching-in-an-index-without-null-values" class="text-decoration-none text-reset"><h2>Searching in an Index without NULL values</h2></a>
<p>We modified the Index slightly, and now it has no NULL values.</p>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT)
INSERT INTO table_test (column1) VALUES (1),(NULL),(NULL),...,(NULL),(NULL),(1000000);
CREATE INDEX idx ON table_test (column1 ASC) WHERE column1 IS NOT NULL;</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, column1 FROM table_test INDEXED BY idx WHERE column1 = 1;
rowid  column1
-----  -------
1      1</code></pre>
<p><a href="./images/search-partial.webp"><img src="./images/search-partial.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>Now, the Index has only the needed values, and the query runs very fast!</p>
<a href="#h2-searching-in-a-two-column-index" id="h2-searching-in-a-two-column-index" class="text-decoration-none text-reset"><h2>Searching in a two-column Index</h2></a>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT NOT NULL, column2 INT NOT NULL);
INSERT INTO table_test (column1, column2) VALUES (1,1),(2,2),(3,3),...,(999998,999998),(999999,999999),(1000000,1000000);
CREATE INDEX idx ON table_test (column1 ASC, column2 ASC);</code></pre>
<pre><code class="language-sql rounded">SELECT rowId, column1, column2 FROM table_test INDEXED BY idx WHERE column1 = 1 AND column2 = 1;
rowid  column1  column2
-----  -------  -------
1      1        1</code></pre>
<p><a href="./images/search-complex-equal.webp"><img src="./images/search-complex-equal.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>The only difference from an Index with one column is the slightly more complex comparison process.<br />
First, the first column is checked. If it matches the target value, then the second column is checked. If the first column doesn’t match, the second column is skipped.<br />
In this case, 19 Cells were read, and 20 comparisons were made. The first 18 Cells were filtered out after the first comparison, and in the 19th Cell, two comparisons were made.</p>
<a href="#h2-searching-in-index-with-different-data-cardinality" id="h2-searching-in-index-with-different-data-cardinality" class="text-decoration-none text-reset"><h2>Searching in Index with different data cardinality</h2></a>
<p>Let's try searching in an Index with two columns, where the columns have different cardinalities. The <code>column1</code> has high cardinality, with values ranging from 1 to 1,000,000, while the <code>column2</code> has low cardinality, with only the values 1 and 2.<br />
We will create two Indexes with different column orders and see how they perform.</p>
<pre><code class="language-sql rounded">CREATE TABLE table_test (column1 INT NOT NULL, column2 INT NOT NULL);
INSERT INTO table_test (column1, column2) VALUES (1,1),(2,2),(3,1),...,(999998,2),(999999,1),(1000000,2);
CREATE INDEX idx_column1_column2 ON table_test (column1 ASC, column2 ASC);
CREATE INDEX idx_column2_column1 ON table_test (column2 ASC, column1 ASC);</code></pre>
<a href="#h3-idx_column1_column2" id="h3-idx_column1_column2" class="text-decoration-none text-reset"><h3>idx_column1_column2</h3></a>
<pre><code class="language-sql rounded">SELECT rowId, column1, column2 FROM table_test INDEXED BY idx_column1_column2 WHERE column1 &gt;= 500000 AND column2 = 2  LIMIT 5;
rowid   column1  column2
------  -------  -------
500000  500000   2      
500002  500002   2      
500004  500004   2      
500006  500006   2      
500008  500008   2</code></pre>
<p><a href="./images/search-complex-cardinality-greater-than-column1.webp"><img src="./images/search-complex-cardinality-greater-than-column1.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>Query details:</p>
<table class="table table-bordered">
<thead class="table-secondary">
<tr>
<th>column1 (&gt;= 5000)</th>
<th>column2 (=2)</th>
<th>comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td>...</td>
<td>search: 19 comparisons on column1</td>
</tr>
<tr>
<td>500000</td>
<td>2</td>
<td>search: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500001</td>
<td>1</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>500002</td>
<td>2</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>500003</td>
<td>1</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>500004</td>
<td>2</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>500005</td>
<td>1</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>500006</td>
<td>2</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>500007</td>
<td>1</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>500008</td>
<td>2</td>
<td>filter: 1 comparison on column2</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td></td>
</tr>
</tbody>
</table>
<p>It took only 21 comparisons to find the first row, but there’s no guarantee that SQLite can quickly filter the remaining rows. In the case below, SQLite has to scan the rest of the Index to ensure there are no more rows that match the query.</p>
<table class="table table-bordered">
<thead class="table-secondary">
<tr>
<th>column1 (&gt;= 500000)</th>
<th>column2 (=2)</th>
<th>comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td>...</td>
<td>search: 19 comparisons on column1</td>
</tr>
<tr>
<td>500000</td>
<td>2</td>
<td>search: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500001</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500002</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500003</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500004</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500005</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500006</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500007</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>500008</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>filter: 999980 comparisons on column1 and column2</td>
</tr>
<tr>
<td>1000000</td>
<td>1</td>
<td>filter: 2 comparisons on column1 and column2</td>
</tr>
</tbody>
</table>
<a href="#h3-idx_column2_column1" id="h3-idx_column2_column1" class="text-decoration-none text-reset"><h3>idx_column2_column1</h3></a>
<pre><code class="language-sql rounded">SELECT rowId, column1, column2 FROM table_test INDEXED BY idx_column2_column1 WHERE column1 &gt;= 500000 AND column2 = 2 LIMIT 5;
rowid   column1  column2
------  -------  -------
500000  500000   2      
500002  500002   2      
500004  500004   2      
500006  500006   2      
500008  500008   2</code></pre>
<p><a href="./images/search-complex-cardinality-greater-than-column2.webp"><img src="./images/search-complex-cardinality-greater-than-column2.webp" alt="" class="img-fluid mx-auto d-block rounded img-max-height" /></a></p>
<p>Query details:</p>
<table class="table table-bordered">
<thead class="table-secondary">
<tr>
<th>column2 (=2)</th>
<th>column1 (&gt;= 5000)</th>
<th>comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td>...</td>
<td>39 comparisons on column1 and column2</td>
</tr>
<tr>
<td>2</td>
<td>500000</td>
<td>2 comparisons on column1 and column2</td>
</tr>
<tr>
<td>2</td>
<td>500002</td>
<td>1 comparison on column1</td>
</tr>
<tr>
<td>2</td>
<td>500004</td>
<td>1 comparison on column1</td>
</tr>
<tr>
<td>2</td>
<td>500006</td>
<td>1 comparison on column1</td>
</tr>
<tr>
<td>2</td>
<td>500008</td>
<td>1 comparison on column1</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td></td>
</tr>
</tbody>
</table>
<p>When the low-cardinality column is placed first, it takes more comparisons to find the first match, but SQLite can quickly filter any remaining rows.<br />
If there are no other matching rows, SQLite knows this after just 2 comparisons.</p>
<p>For a query with only one result row, it’s better to use an Index where the high-cardinality column is placed first.<br />
For a query with many result rows, it’s better to use an Index with the range column at the end, regardless of the column's cardinality.</p>
<a href="#h2-conclusion" id="h2-conclusion" class="text-decoration-none text-reset"><h2>Conclusion</h2></a>
<p>The visualization of Index search operations in SQLite gives us a better understanding of how the database works with its internal data structures.<br />
Detailed logs allow us to see not just the number of operations but also the steps taken to find the desired values.<br />
Understanding SQLite's inner workings helps us optimize queries and makes working with Indexes more predictable and manageable.</p>
<p>All the images generated above can be reproduced using the following commands:</p>
<pre><code class="language-bash rounded">docker run -it --rm -v "$PWD":/app/data --platform linux/x86_64 mrsuh/sqlite-index bash
sh bin/test-search.sh</code></pre>
<p>The code and examples are available <a href="https://github.com/mrsuh/sqlite-index" target="_blank">here</a></p>
</div>

<div class="footer" style="height: 40px"></div>
</body>
<link rel="stylesheet" href="/highlight.github-dark-dimmed.min.css">
<script src="/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

</html>
